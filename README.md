Comparing build systems performance for a large C project.

Requirements
------------

- support more than 1000 files in the project
- support build 'fragments' in each subdirectory
- take advantage of gcc automatic dependencies

Please refer to this [blog post](http://kaizou.org/2016/09/build-benchmark-large-c-project/) for details about the solutions.

Results
-------

I ran the benchmark on a Intel Core i7 with 16 GB RAM and an SSD drive.

All build times are in seconds.

Tree = 2 levels, 10 subdirectories per level (12 .c files)

	|               | kbuild | nrecur | static | cmake | boilermake | ninja |
	|---------------|--------|--------|--------|-------|------------|-------|
	| cold start    | 0.08   | 0.06   | 0.08   | 0.55  | 0.08       | 0.36  |
	| full rebuild  | 0.06   | 0.06   | 0.06   | 0.23  | 0.07       | 0.04  |
	| rebuild leaf  | 0.04   | 0.03   | 0.03   | 0.16  | 0.04       | 0.05  |
	| nothing to do | 0.01   | 0.00   | 0.00   | 0.06  | 0.01       | 0.00  |

Tree = 3 levels, 10 subdirectories per level (112 .c files)

	|               | kbuild | nrecur | static | cmake | boilermake | ninja |
	|---------------|--------|--------|--------|-------|------------|-------|
	| cold start    | 0.47   | 0.45   | 0.60   | 1.84  | 0.52       | 0.91  |
	| full rebuild  | 0.48   | 0.46   | 0.46   | 1.34  | 0.54       | 0.39  |
	| rebuild leaf  | 0.11   | 0.10   | 0.11   | 0.46  | 0.11       | 0.00  |
	| nothing to do | 0.06   | 0.05   | 0.06   | 0.40  | 0.07       | 0.00  |

Tree = 4 levels, 10 subdirectories per level (1112 .c files)

	|               | kbuild | nrecur | static | cmake | boilermake | ninja |
	|---------------|--------|--------|--------|-------|------------|-------|
	| cold start    | 4.62   | 4.57   | 6.94   | 16.72 | 5.48       | 7.50  |
	| full rebuild  | 4.85   | 4.57   | 5.26   | 15.12 | 5.56       | 6.39  |
	| rebuild leaf  | 0.98   | 0.86   | 1.37   |  4.47 | 1.07       | 0.28  |
	| nothing to do | 0.53   | 0.67   | 1.22   |  4.44 | 0.88       | 0.05  |

Tree = 5 levels, 10 subdirectories per level (11112 .c files)

	|               | kbuild | nrecur | static | cmake  | boilermake | ninja  |
	|---------------|--------|--------|--------|--------|------------|--------|
	| cold start    | 59.01  | 54.07  | 164.03 | 509.96 | 72.41      | 175.58 |
	| full rebuild  | 63.41  | 61.38  | 130.83 | 376.40 | 80.17      | 101.76 |
	| rebuild leaf  | 10.86  | 17.18  |  88.37 | 215.44 | 20.19      |   2.81 |
	| nothing to do |  5.13  | 14.95  |  86.00 | 220.49 | 17.78      |   0.47 |

My two cents
------------

From the results above, I conclude that:

- for my use case, and with my hardware (I suspect SSD is a huge bonus for recursive Make), non-recursive and recursive Makefiles are equivalent,
- my generated Makefile is completely suboptimal (would need to investigate),
- CMake generated Makefiles are pretty darn slow ...
- ninja is the fastest build-system when only a few files have changed,
- it would be interesting to check the performance of a vanilla Ninja build (ie not generated by CMake).
